{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LogosJ is a Javascipt package for creating SVG sequence logos. In addition to basic DNA, RNA, and protein logos, we support custom alphabets and variety of advanced logo types and custom annotations. LogosJ can be used with and without ReactJS. A companion web app makes it easy to share SVG logos and generate them in batches from the output of common tools such as the MEME Suite. Examples LogosJ supports a wide range of biological use cases. Detailed examples with code samples are available in this documentation and through our companion site . Shown below are protein, RNA, methyl DNA, dinucleotide, and protein/DNA interaction logos. DNA and RNA logos protein logo advanced annotations Using in your web application You can add LogosJ to your project using NPM or Yarn: yarn add logosj-react or npm install logosj-react If you want to use LogosJ in a static web page, you can simply include the package with a static script tag, which will add LogosJ to the global namespace as logosj : script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script Quick example: a DNA logo The transcription factor CTCF binds a well-known consensus DNA sequence, rendered below with LogosJ: If you use ReactJS, the following code creates the CTCF consensus binding logo: import { DNALogo } from logosj-react ; const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const CTCFLogo = props = ( DNALogo ppm = { CTCF_PPM } / ); If you don t use React, the following code embeds the DNA logo in a div element: !doctype html html body script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedDNALogo ( document . getElementById ( logo ), { ppm : CTCF_PPM }); / script / body / html","title":"LogosJ: Embeddable SVG Sequence Logos"},{"location":"#examples","text":"LogosJ supports a wide range of biological use cases. Detailed examples with code samples are available in this documentation and through our companion site . Shown below are protein, RNA, methyl DNA, dinucleotide, and protein/DNA interaction logos. DNA and RNA logos protein logo advanced annotations","title":"Examples"},{"location":"#using-in-your-web-application","text":"You can add LogosJ to your project using NPM or Yarn: yarn add logosj-react or npm install logosj-react If you want to use LogosJ in a static web page, you can simply include the package with a static script tag, which will add LogosJ to the global namespace as logosj : script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script","title":"Using in your web application"},{"location":"#quick-example-a-dna-logo","text":"The transcription factor CTCF binds a well-known consensus DNA sequence, rendered below with LogosJ: If you use ReactJS, the following code creates the CTCF consensus binding logo: import { DNALogo } from logosj-react ; const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const CTCFLogo = props = ( DNALogo ppm = { CTCF_PPM } / ); If you don t use React, the following code embeds the DNA logo in a div element: !doctype html html body script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedDNALogo ( document . getElementById ( logo ), { ppm : CTCF_PPM }); / script / body / html","title":"Quick example: a DNA logo"},{"location":"alphabet/","text":"Built-in and custom alphabets Alphabet overview LogosJ combines sets of individual glyphs into alphabets. An alphabet is an array of symbols , each of which should have a unique color and glyph combination. Symbols are not restricted to just one glyph; if you are rendering a dinucleotide logo, for example, you might use symbols with two glyphs each. Alphabets can also have multiple symbols that use the same glyph with different colors (for example one red A and one gray A ). When you are building your PWM, the order of the columns corresponds to the order of the symbols in your alphabet array. The symbol objects in an alphabet have the following fields: color an array of colors to use for each letter in the symbol. If the symbol is only one letter, a single value may be used in place of an array. component an array of components used to render the glyphs in this symbol. Should be the same length as color . If your alphabet uses custom glyphs, import your custom glyph components and use them here. If the symbol is only one letter, a single component may be used in place of an array. If you are only using letters and digits which are built in to LogosJ, you can use the regex field instead, and LogosJ will populate this field for you using the loadGlyphComponents function. function. regex a string representing the sequence of letters in this symbol. This field is not required, but may be used as a shorthand rather than explicitly including components in the component field. LogosJ will populate the components field for you automatically with matching built-in letters and digits if you leave it empty. Built-in alphabets LogosJ provides built-in alphabets for common use cases for convenience. If you need to render a custom logo with these symbol sets, you can import these alphabets rather than build them yourself. In React, these can be imported directly from the logosj package; without React, they are accessible under the logosj namespace (i.e. logosj.DNAAlphabet ). The DNAAlphabet renders logos with a DNA symbol set. A is red, C is blue, G is gold, and T is green; columns in the PWM are in that order. The RNAAlphabet renders logos with an RNA symbol set. A is red, C is blue, G is gold, and U is green; columns in the PWM are in that order. The ProteinAlphabet renders logos with a protein symbol set. Acidic amino acids are red, basic amino acids are blue, and non-polar amino acids are black. B is used for D or N and Z is used for E or Q ; both are gold. The CompleteAlphabet includes the capital letters A-Z, then the lower case letters a-z, then the digits 0-9, all in that order and with custom colors. This can be used for experimentation with different symbols. Custom alphabets To make a custom alphabet, simply create a custom array of symbol objects as described above. If you have custom React components for custom glyphs not built-in to LogosJ, you can include them in the components field. The following is an example of a custom alphabet with M and W representing methylated CpG on the plus and minus strands (the syntax below first includes the core of the DNAAlphabet , then extends it with M and W ): import { DNAAlphabet , loadGlyphComponents } from logosj ; export const METHYL_ALPHABET = loadGlyphComponents ([ ... DNAAlphabet , { color : #880088 , regex : M }, { color : #888800 , regex : W } ]); Alphabet utilities LogosJ provides two utility functions to make generating custom alphabets easier in particular use cases. The loadGlyphComponents function reads the optional regex field of each symbol in a custom alphabet and automatically populates the corresponding component field with built-in glyphs from LogosJ. If a symbol has a component field already but has no regex field, it will be left unchanged; however, if it has a regex field and a components field the contents of the components field will be overwritten. The regex field must only contain the letters A-Z and a-z and the digits 0-9. The function takes the following argument: alphabet the custom alphabet, containing regex fields for each symbol; this parameter remains unchanged, and a copy with component fields is returned. The disymbolAlphabet function takes a custom alphabet and generates a new custom alphabet with every possible pairing of symbols from the original. Colors for individual letters are retained. For example, given the DNAAlphabet as input, this function would generate a new alphabet with the symbols AA , AC , AG , AT , CA , TT . The function takes a single argument: alphabet the input alphabet; remains unchanged. A new disymbol alphabet is returned.","title":"Built-in and custom alphabets"},{"location":"alphabet/#built-in-and-custom-alphabets","text":"","title":"Built-in and custom alphabets"},{"location":"alphabet/#alphabet-overview","text":"LogosJ combines sets of individual glyphs into alphabets. An alphabet is an array of symbols , each of which should have a unique color and glyph combination. Symbols are not restricted to just one glyph; if you are rendering a dinucleotide logo, for example, you might use symbols with two glyphs each. Alphabets can also have multiple symbols that use the same glyph with different colors (for example one red A and one gray A ). When you are building your PWM, the order of the columns corresponds to the order of the symbols in your alphabet array. The symbol objects in an alphabet have the following fields: color an array of colors to use for each letter in the symbol. If the symbol is only one letter, a single value may be used in place of an array. component an array of components used to render the glyphs in this symbol. Should be the same length as color . If your alphabet uses custom glyphs, import your custom glyph components and use them here. If the symbol is only one letter, a single component may be used in place of an array. If you are only using letters and digits which are built in to LogosJ, you can use the regex field instead, and LogosJ will populate this field for you using the loadGlyphComponents function. function. regex a string representing the sequence of letters in this symbol. This field is not required, but may be used as a shorthand rather than explicitly including components in the component field. LogosJ will populate the components field for you automatically with matching built-in letters and digits if you leave it empty.","title":"Alphabet overview"},{"location":"alphabet/#built-in-alphabets","text":"LogosJ provides built-in alphabets for common use cases for convenience. If you need to render a custom logo with these symbol sets, you can import these alphabets rather than build them yourself. In React, these can be imported directly from the logosj package; without React, they are accessible under the logosj namespace (i.e. logosj.DNAAlphabet ). The DNAAlphabet renders logos with a DNA symbol set. A is red, C is blue, G is gold, and T is green; columns in the PWM are in that order. The RNAAlphabet renders logos with an RNA symbol set. A is red, C is blue, G is gold, and U is green; columns in the PWM are in that order. The ProteinAlphabet renders logos with a protein symbol set. Acidic amino acids are red, basic amino acids are blue, and non-polar amino acids are black. B is used for D or N and Z is used for E or Q ; both are gold. The CompleteAlphabet includes the capital letters A-Z, then the lower case letters a-z, then the digits 0-9, all in that order and with custom colors. This can be used for experimentation with different symbols.","title":"Built-in alphabets"},{"location":"alphabet/#custom-alphabets","text":"To make a custom alphabet, simply create a custom array of symbol objects as described above. If you have custom React components for custom glyphs not built-in to LogosJ, you can include them in the components field. The following is an example of a custom alphabet with M and W representing methylated CpG on the plus and minus strands (the syntax below first includes the core of the DNAAlphabet , then extends it with M and W ): import { DNAAlphabet , loadGlyphComponents } from logosj ; export const METHYL_ALPHABET = loadGlyphComponents ([ ... DNAAlphabet , { color : #880088 , regex : M }, { color : #888800 , regex : W } ]);","title":"Custom alphabets"},{"location":"alphabet/#alphabet-utilities","text":"LogosJ provides two utility functions to make generating custom alphabets easier in particular use cases. The loadGlyphComponents function reads the optional regex field of each symbol in a custom alphabet and automatically populates the corresponding component field with built-in glyphs from LogosJ. If a symbol has a component field already but has no regex field, it will be left unchanged; however, if it has a regex field and a components field the contents of the components field will be overwritten. The regex field must only contain the letters A-Z and a-z and the digits 0-9. The function takes the following argument: alphabet the custom alphabet, containing regex fields for each symbol; this parameter remains unchanged, and a copy with component fields is returned. The disymbolAlphabet function takes a custom alphabet and generates a new custom alphabet with every possible pairing of symbols from the original. Colors for individual letters are retained. For example, given the DNAAlphabet as input, this function would generate a new alphabet with the symbols AA , AC , AG , AT , CA , TT . The function takes a single argument: alphabet the input alphabet; remains unchanged. A new disymbol alphabet is returned.","title":"Alphabet utilities"},{"location":"config/","text":"Configuration Krews requires configuration files to run. These files, along with command line arguments allow you to tweak how your workflow runs without touching or building your Krews application. The application itself is more concerned with what runs. In this way it is a means of separation of concerns . Configurations cover things like execution environment settings and parallelism. They also cover special parameters that you set up in your Krews Application to pass in differently for each run. They allow you to provide your workflow to 3 rd parties as an executable. The only thing your users would then need to worry about is creating a config. Krews configuration files are written in a superset of JSON called HOCON . It s just JSON with some additional syntax sugar that helps keep it concise and readable. These files conventionally use the extension .conf . There are two types of configurations, workflow scope and task scope. Workflow Configurations Workflow scope configurations apply to the entire workflow. They live at the top level of your configuration documents. Common Workflow Configurations The following are workflow configurations common for running against any execution environment. config name description required default parallelism The maximum number of tasks allowed to run concurrently. Set to an integer or unlimited no unlimited report-generation-delay Delay (in seconds) between generating updated status reports no 60 Example parallelism = 10 report-generation-delay = 180 Local Docker Execution Specific name description required default local.docker Docker client configurations. In most cases you should not need to set these. no none local.docker.uri URI of docker daemon no none local.docker.certificates-path Path to certificate for TLS enabled docker daemon no none local.docker.connect-timeout Timeout (in milliseconds) for connecting to docker daemon no 5000 local.docker.read-timeout Timeout (in milliseconds) for reading data from docker daemon no 30000 local.docker.connection-pool-size Connection pool size for docker client no 100 Example local { docker { uri = localhost:1234 certificate-path = ~/my-path/my-cert.cert connect-timeout = 10000 read-timeout = 60000 connection-pool-size = 200 } } Google Cloud Execution Specific name description required default google.project-id Google Cloud project ID yes none google.regions List of regions in which we re allow to create VMs no none google.bucket Google Cloud Storage bucket where we will be keeping our workflow files yes none google.job-completion-poll-interval Interval (in seconds) between checks for pipeline job completion no 10 google.log-upload-interval Interval (in seconds) between pipeline job log uploads to storage no 60 Example google { project-id = my-project regions = [us-east1, us-east2] bucket = my-bucket job-completion-poll-interval = 60 log-upload-interval = 120 } Slurm Execution Specific name description required default slurm.job-completion-poll-interval Interval (in seconds) between checks for pipeline job completion no 10 slurm.ssh Used to connect to Slurm head node to run sbatch jobs and poll job status. Enables running remote machines that can ssh to slurm head node with passwordless login no none slurm.ssh.user User for Slurm head node ssh no none slurm.ssh.host Slurm head node host name no none slurm.ssh.port Slurm head node ssh port no 22 Example slurm { job-completion-poll-interval = 30 ssh { user = jbrooks host = slurm018 port = 23 } } Task Configurations Task scope configurations apply to only individual tasks. They live under special sections of your configuration files. // task configs in this section apply to ALL tasks task.default { //... } // task configs in this section apply to tasks with a name matching my-task-name task.my-task-name { //... } // task configs in this section apply to tasks with a label matching my-task-label task.my-task-label { //... } Some of these sections match our application tasks based on names and labels. These are based on fields you use when you create your tasks. task MyTaskInput ( my-task-name , my-task-label , my-other-task-label ) { // ... } Note that these fields must be hyphenated-snake-case but names. Since labels are free-form string fields, if you use a string like My Task.Name! , it will automatically be converted to deserialize from my-task-name . It is recommended you make all task names and labels hyphenated-snake-case to match configurations. Task configurations will be merged for each task before deserializing, so you could set one setting in task.default , one in task.my-task-name , and one in task.my-task-label they could all be passed into a task. Common Task Configurations name description required default parallelism The maximum number of this task that can run concurrently. Set to an integer or unlimited. no unlimited grouping The number of task runs that are submitted per job for this task. Not applicable to Local Docker Execution. no 1 Example task.my-task-name { parallelism = 10 grouping = 5 } Google Cloud Execution Specific name description required default google.machine-type A native google compute engine machine type (See here for complete list). If this is set, it s always used regardless of other configs. no none google.machine-class A class of machine. Useful for when you don t know the needed resources until runtime. Options are: standard, highmem, highcpu, ultramem, custom no none google.cpus Number of CPUs. Can be used to override the runtime value. no none google.mem Amount of memory. Can be used to override the runtime value. no none google.mem-per-cpu An optional memory per cpu ratio used when you don t have both fields available and don t want to use a machine class. no none google.disk-size Disk capacity. Can be used to override the runtime value. no none google.disk-type Type of disk, HDD vs SSD. no hdd *Please note most of these settings are mutually exclusive. For example, a machine-class is not needed if you have a machine-type set. Example task.my-task-name { google { machine-type = n1-standard-2 machine-class = standard cpus = 2 mem = 8GB mem-per-cpu = 2GB disk-size = 1TB disk-type = ssd } } Slurm Execution Specific name description required default slurm.cpus Number of cpus. Can be used to override the runtime value. no none slurm.mem Amount of memory. Can be used to override the runtime value. no none slurm.time Time limit on the run time for the job in minutes. no none slurm.partition SBatch partition to use. no none slurm.sbatch-args Additional sbatch args used with our sbatch commands to initiate jobs. See reference . no none Example task.my-task-name { slurm { cpus = 4 mem = 16GB time = 120 partition = my-partition sbatch-args = --nodes=2 --overcommit -priority=TOP } } Parameters As mentioned in the workflows section, workflows and tasks have parameters customized in your application that get injected from configuration files. These are registered in your application as classes. The process of turning JSON (and HOCON) into objects of these classes is called deserialization. We do this using the Jackson library. Workflow Parameters If your workflow contains the following data class SampleParams ( val message : String , // The ? means this is optional and will be null by default val flag : Boolean ?, // This has a default value of 10, so we don t actually need to set it in our config val rangeMax : Int = 10 ) val sampleWorkflow = workflow ( sample-workflow ) { val params = params SampleParams () //... } You will be able to inject the following as parameters params { message = Hello World! range-max = 5 } Notice that the rangeMax data class field was automatically converted to a hyphenated-snake-case version range-max . This will happen for all params. Task Parameters Just like for workflows, we have custom parameters that can be injected into each task. data class MyTaskParams ( val someSetting : Boolean ) task MyTaskInput ( my-task-name , my-task-label , my-other-task-label ) { val taskParams = taskParams MyTaskParams //... } task.my-task-name { params { some-setting = true } } Ambiguity in Deserialization For abstract classes and interfaces, we have special considerations in deserialization. Consider the following: // In model/Pet.kt interface Pet data class Dog ( val barkVolume : Int ) : Pet data class Cat ( val meowVolume : Int ) : Pet // In App.kt data class SampleParams ( val pet : Pet ) val sampleWorkflow = workflow ( sample-workflow ) { val params = params SampleParams () //... } Since the pet parameter in HOCON is a type that is not concrete, Krews allows you to provide the concrete type. params { pet { -type = model.Dog bark-volume = 50 } } Input Files as Parameters One of the most common uses of params is to provide files for each run. These files will be provided as InputFiles. The InputFile class is abstract, so when we pass them in we need to pass in implementations like GSInputFile for files in Google Cloud Storage and LocalInputFile for files on your local file system. Here s an example params for a list of InputFiles data class SampleParams ( val myFiles : List InputFile ) val sampleWorkflow = workflow ( sample-workflow ) { val params = params SampleParams () //... } params { my-files = [ { -type = krews.file.GSInputFile bucket = my-bucket object-path = some/object/path/file1.tar path = path/file1.tar }, { -type = krews.file.GSInputFile bucket = my-bucket object-path = some/object/path/file2.tar path = path/file2.tar } ] }","title":"Configuration"},{"location":"config/#configuration","text":"Krews requires configuration files to run. These files, along with command line arguments allow you to tweak how your workflow runs without touching or building your Krews application. The application itself is more concerned with what runs. In this way it is a means of separation of concerns . Configurations cover things like execution environment settings and parallelism. They also cover special parameters that you set up in your Krews Application to pass in differently for each run. They allow you to provide your workflow to 3 rd parties as an executable. The only thing your users would then need to worry about is creating a config. Krews configuration files are written in a superset of JSON called HOCON . It s just JSON with some additional syntax sugar that helps keep it concise and readable. These files conventionally use the extension .conf . There are two types of configurations, workflow scope and task scope.","title":"Configuration"},{"location":"config/#workflow-configurations","text":"Workflow scope configurations apply to the entire workflow. They live at the top level of your configuration documents.","title":"Workflow Configurations"},{"location":"config/#common-workflow-configurations","text":"The following are workflow configurations common for running against any execution environment. config name description required default parallelism The maximum number of tasks allowed to run concurrently. Set to an integer or unlimited no unlimited report-generation-delay Delay (in seconds) between generating updated status reports no 60 Example parallelism = 10 report-generation-delay = 180","title":"Common Workflow Configurations"},{"location":"config/#local-docker-execution-specific","text":"name description required default local.docker Docker client configurations. In most cases you should not need to set these. no none local.docker.uri URI of docker daemon no none local.docker.certificates-path Path to certificate for TLS enabled docker daemon no none local.docker.connect-timeout Timeout (in milliseconds) for connecting to docker daemon no 5000 local.docker.read-timeout Timeout (in milliseconds) for reading data from docker daemon no 30000 local.docker.connection-pool-size Connection pool size for docker client no 100 Example local { docker { uri = localhost:1234 certificate-path = ~/my-path/my-cert.cert connect-timeout = 10000 read-timeout = 60000 connection-pool-size = 200 } }","title":"Local Docker Execution Specific"},{"location":"config/#google-cloud-execution-specific","text":"name description required default google.project-id Google Cloud project ID yes none google.regions List of regions in which we re allow to create VMs no none google.bucket Google Cloud Storage bucket where we will be keeping our workflow files yes none google.job-completion-poll-interval Interval (in seconds) between checks for pipeline job completion no 10 google.log-upload-interval Interval (in seconds) between pipeline job log uploads to storage no 60 Example google { project-id = my-project regions = [us-east1, us-east2] bucket = my-bucket job-completion-poll-interval = 60 log-upload-interval = 120 }","title":"Google Cloud Execution Specific"},{"location":"config/#slurm-execution-specific","text":"name description required default slurm.job-completion-poll-interval Interval (in seconds) between checks for pipeline job completion no 10 slurm.ssh Used to connect to Slurm head node to run sbatch jobs and poll job status. Enables running remote machines that can ssh to slurm head node with passwordless login no none slurm.ssh.user User for Slurm head node ssh no none slurm.ssh.host Slurm head node host name no none slurm.ssh.port Slurm head node ssh port no 22 Example slurm { job-completion-poll-interval = 30 ssh { user = jbrooks host = slurm018 port = 23 } }","title":"Slurm Execution Specific"},{"location":"config/#task-configurations","text":"Task scope configurations apply to only individual tasks. They live under special sections of your configuration files. // task configs in this section apply to ALL tasks task.default { //... } // task configs in this section apply to tasks with a name matching my-task-name task.my-task-name { //... } // task configs in this section apply to tasks with a label matching my-task-label task.my-task-label { //... } Some of these sections match our application tasks based on names and labels. These are based on fields you use when you create your tasks. task MyTaskInput ( my-task-name , my-task-label , my-other-task-label ) { // ... } Note that these fields must be hyphenated-snake-case but names. Since labels are free-form string fields, if you use a string like My Task.Name! , it will automatically be converted to deserialize from my-task-name . It is recommended you make all task names and labels hyphenated-snake-case to match configurations. Task configurations will be merged for each task before deserializing, so you could set one setting in task.default , one in task.my-task-name , and one in task.my-task-label they could all be passed into a task.","title":"Task Configurations"},{"location":"config/#common-task-configurations","text":"name description required default parallelism The maximum number of this task that can run concurrently. Set to an integer or unlimited. no unlimited grouping The number of task runs that are submitted per job for this task. Not applicable to Local Docker Execution. no 1 Example task.my-task-name { parallelism = 10 grouping = 5 }","title":"Common Task Configurations"},{"location":"config/#google-cloud-execution-specific_1","text":"name description required default google.machine-type A native google compute engine machine type (See here for complete list). If this is set, it s always used regardless of other configs. no none google.machine-class A class of machine. Useful for when you don t know the needed resources until runtime. Options are: standard, highmem, highcpu, ultramem, custom no none google.cpus Number of CPUs. Can be used to override the runtime value. no none google.mem Amount of memory. Can be used to override the runtime value. no none google.mem-per-cpu An optional memory per cpu ratio used when you don t have both fields available and don t want to use a machine class. no none google.disk-size Disk capacity. Can be used to override the runtime value. no none google.disk-type Type of disk, HDD vs SSD. no hdd *Please note most of these settings are mutually exclusive. For example, a machine-class is not needed if you have a machine-type set. Example task.my-task-name { google { machine-type = n1-standard-2 machine-class = standard cpus = 2 mem = 8GB mem-per-cpu = 2GB disk-size = 1TB disk-type = ssd } }","title":"Google Cloud Execution Specific"},{"location":"config/#slurm-execution-specific_1","text":"name description required default slurm.cpus Number of cpus. Can be used to override the runtime value. no none slurm.mem Amount of memory. Can be used to override the runtime value. no none slurm.time Time limit on the run time for the job in minutes. no none slurm.partition SBatch partition to use. no none slurm.sbatch-args Additional sbatch args used with our sbatch commands to initiate jobs. See reference . no none Example task.my-task-name { slurm { cpus = 4 mem = 16GB time = 120 partition = my-partition sbatch-args = --nodes=2 --overcommit -priority=TOP } }","title":"Slurm Execution Specific"},{"location":"config/#parameters","text":"As mentioned in the workflows section, workflows and tasks have parameters customized in your application that get injected from configuration files. These are registered in your application as classes. The process of turning JSON (and HOCON) into objects of these classes is called deserialization. We do this using the Jackson library.","title":"Parameters"},{"location":"config/#workflow-parameters","text":"If your workflow contains the following data class SampleParams ( val message : String , // The ? means this is optional and will be null by default val flag : Boolean ?, // This has a default value of 10, so we don t actually need to set it in our config val rangeMax : Int = 10 ) val sampleWorkflow = workflow ( sample-workflow ) { val params = params SampleParams () //... } You will be able to inject the following as parameters params { message = Hello World! range-max = 5 } Notice that the rangeMax data class field was automatically converted to a hyphenated-snake-case version range-max . This will happen for all params.","title":"Workflow Parameters"},{"location":"config/#task-parameters","text":"Just like for workflows, we have custom parameters that can be injected into each task. data class MyTaskParams ( val someSetting : Boolean ) task MyTaskInput ( my-task-name , my-task-label , my-other-task-label ) { val taskParams = taskParams MyTaskParams //... } task.my-task-name { params { some-setting = true } }","title":"Task Parameters"},{"location":"config/#ambiguity-in-deserialization","text":"For abstract classes and interfaces, we have special considerations in deserialization. Consider the following: // In model/Pet.kt interface Pet data class Dog ( val barkVolume : Int ) : Pet data class Cat ( val meowVolume : Int ) : Pet // In App.kt data class SampleParams ( val pet : Pet ) val sampleWorkflow = workflow ( sample-workflow ) { val params = params SampleParams () //... } Since the pet parameter in HOCON is a type that is not concrete, Krews allows you to provide the concrete type. params { pet { -type = model.Dog bark-volume = 50 } }","title":"Ambiguity in Deserialization"},{"location":"config/#input-files-as-parameters","text":"One of the most common uses of params is to provide files for each run. These files will be provided as InputFiles. The InputFile class is abstract, so when we pass them in we need to pass in implementations like GSInputFile for files in Google Cloud Storage and LocalInputFile for files on your local file system. Here s an example params for a list of InputFiles data class SampleParams ( val myFiles : List InputFile ) val sampleWorkflow = workflow ( sample-workflow ) { val params = params SampleParams () //... } params { my-files = [ { -type = krews.file.GSInputFile bucket = my-bucket object-path = some/object/path/file1.tar path = path/file1.tar }, { -type = krews.file.GSInputFile bucket = my-bucket object-path = some/object/path/file2.tar path = path/file2.tar } ] }","title":"Input Files as Parameters"},{"location":"custom/","text":"Custom Logos Overview LogosJ supports a wide array of customizations for logos. You can use custom alphabets, make logos where some letters extend below the x-axis, or take advantage of SVG components to layer on custom annotations. Several advanced React components are available offering varying degrees of customization. Custom alphabets You can use any combination of symbols you like in your logos. The custom alphabets page in the Building blocks: glyphs and alphabets section has details. Once you have a custom alphabet, you can render a logo with it using the Logo component, which takes the following properties: values : a matrix containing nucleotide frequencies at each position. Each row is a position in the logo, and the columns correspond to the symbol order defined in the alphabet array. mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. alphabet : the custom alphabet containing the symbols the logos should render. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default 1 / (alphabet length). The order of the array matches the order of alphabet . If mode is not INFORMATION_CONTENT, this is ignored. The following complete example renders a logo with M and W representing methylated CpG : import { Logo } from logosj-react ; const METHYL_VALUES = [ [ 0 , 0 , 0 , 1 , 0 , 0 ] [ 0 , 0 , 0 , 1 , 0 , 0 ] [ 0.3 , 0 , 0.3 , 0.4 , 0 , 0 ] [ 0 , 0 , 0 , 0 , 1 , 0 ] [ 0 , 0 , 0 , 0 , 0 , 1 ] [ 0 , 0.6 , 0 , 0.4 , 0 , 0 ] [ 1 , 0 , 0 , 0 , 0 , 0 ] ]; const METHYL_ALPHABET = [ { color : #880088 , regex : A } { color : #880000 , regex : C } { color : #000088 , regex : G } { color : #888800 , regex : T } { color : #ff0000 , regex : M } { color : #008888 , regex : W } ]; export const MethylLogo = props = ( Logo values = { METHYL_VALUES } alphabet = { METHYL_ALPHABET } / ); To embed a Logo outside of React, use the embedLogo function, which takes the following arguments: div the div element in which to render the logo properties object containing the properties listed above Negative letters The LogosWithNegatives component allows letters to extend below the x-axis. In this case, the values in the matrix represent the raw heights above (or below) the x-axis, and the y-axis will autoscale. The component accepts the following properties: values matrix containing the heights of the letters at each position; values can be positive or negative. startpos if set, the first base in the logo will be numbered with a value other than the default of 1. alphabet the custom alphabet containing the symbols the logos should render. negativealpha if provided, specifies that letters below the x-axis should be semi-transparent inverted if provided, specifies that letters below the x-axis should be rendered upright rather than upside-down, which is the default. The following complete example renders a DNA logo with some negative letters: import { LogoWithNegatives , DNAAlphabet } from logosj-react ; const DNA_VALUES = [ [ 0 , 0 , 0 , 0 ], [ - 0.5 , 0.5 , - 0.5 , 0.5 ], [ 0.5 , - 2 , - 2 , 3 ], [ 2.5 , - 2 , 0.5 , - 0.5 ], [ 4.5 , - 1 , - 2 , - 2.5 ], [ - 1 , - 1 , 0 , 2 ], [ - 1.5 , - 0.5 , 0.5 , 1.5 ], [ 1.5 , - 1.5 , 1 , - 0.5 ], [ - 1 , 1 , 0 , 0 ] [ 0 , 0 , 0 , 0 ] ]; export const DNALogo = props = ( LogoWithNegatives values = { DNA_VALUES } alphabet = { DNAAlphabet } negativealpha = { 101 } / ); To embed a LogoWithNegatives outside of React, use the embedLogoWithNegatives function, which takes the following arguments: div the div element in which to render the logo properties object containing the properties listed above Logos without axes Logos do not need to be rendered with the default, built-in axes. LogosJ provides a RawLogo component which just renders glyphs. A RawLogo component does not render its own svg tag; you need to provide it yourself. This adds flexibility, however, to render the logo on top of other SVG annotations. The value matrix passed to a RawLogo specifies the raw heights of the contained letters. A value of 1 will render a letter which is 100 units high, relative to the SVG s coordinate system. By default, all positions are 100 units wide. RawLogo components support multiple letters per symbol. A RawLogo takes the following properties: values matrix containing the raw heights of the letters (divided by a factor of 100 units relative to the SVG s coordinate system). glyphWidth the width of a single glyph relative to the containing SVG s coordinate system; defaults to 100. stackHeight the height of a single stack of glyphs relative to the containing SVG s coordinate system; defaults to 100. Individual letters can exceed this, in which case they may extend past the SVG s borders. alphabet the custom alphabet containing the symbols the logos should render. The following example renders a RawLogo containing a DNA sequence with some letters grayed out. Note that the RawLogo must be rendered within a containing svg , and is shifted to the desired position by transforming a g element: import { RawLogo } from logosj-react ; const ANNOTATED_VALUES = [ [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 ] [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 0 , 0.25 , 0.25 , 0.25 , 0.25 ] [ 0 , 0 , 0 , 0 , 0.25 , 0.25 , 0.25 , 0.25 ] [ 0 , 0 , 0 , 0 , 0.25 , 0.25 , 0.25 , 0.25 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] [ 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] ]; const ANNOTATED_ALPHABET = [ { regex : A , color : red } { regex : C , color : blue } { regex : G , color : orange } { regex : T , color : #228b22 } { color : #aaaaaa , regex : A } { color : #aaaaaa , regex : C } { color : #aaaaaa , regex : G } { color : #aaaaaa , regex : T } ]; export const AnnotatedLogo = props = ( svg viewBox = 0 0 1530 330 g transform = translate(20,-40) id = logo RawLogo values = { ANNOTATED_VALUES } alphabet = { ANNOTATED_ALPHABET } glyphWidth = { 100 } stackHeight = { 300 } / /g /svg ); To embed a RawLogo outside of React, use the embedRawLogo function, which takes the following arguments: element the SVG element in which to render the logo properties object containing the properties listed above Custom annotations When a RawLogo is rendered within an svg , a variety of custom annotations can be layered on as desired using custom SVG components. The following example renders two logos on top of each other, one representing a reference sequence with a SNP and the other a motif interrupted by the SNP. The SNP is highlighted in gray and the logos labeled with text labels. For more examples, see our companion site, http://logosj.wenglab.org/ . import { RawLogo , DNAAlphabet } from logosj-react ; const SNP_VALUES = [ [ 0.05 , 0.05 , 0 , 0 ] [ 0 , 0 , 0.3 , 0.7 ] [ 0 , 0 , 0.05 , 0.05 ] [ 0 , 0 , 0 , 2 ] [ 0.6 , 0 , 0 , 0.8 ] [ 0 , 2 , 0 , 0 ] [ 0.8 , 0.8 , 0 , 0 ] [ 0 , 0 , 0.1 , 0 ] ]; const REFERENCE_VALUES = [ [ 2 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 ] [ 2 , 0 , 0 , 0 ] [ 0 , 2 , 0 , 0 ] [ 0 , 0 , 0 , 2 ] [ 0 , 2 , 0 , 0 ] [ 0 , 2 , 0 , 0 ] [ 0 , 0 , 0 , 2 ] ]; export const SNPLogo = props = ( svg viewBox = 0 0 1100 420 rect x = { 600 } width = { 100 } height = { 420 } fill = #bbbbbb / g transform = translate(300,0) RawLogo alphabet = { DNAAlphabet } values = { SNP_VALUES } glyphWidth = { 100 } stackHeight = { 200 } / /g g transform = translate(300, 220) RawLogo alphabet = { DNAAlphabet } values = { REFERENCE_VALUES } glyphWidth = { 100 } stackHeight = { 200 } / /g text y = { 150 } x = { 260 } textAnchor = end style = {{ fontSize : 50px }} motif /text text y = { 350 } x = { 260 } textAnchor = end style = {{ fontSize : 50px }} reference /text /svg );","title":"Custom Logos"},{"location":"custom/#custom-logos","text":"","title":"Custom Logos"},{"location":"custom/#overview","text":"LogosJ supports a wide array of customizations for logos. You can use custom alphabets, make logos where some letters extend below the x-axis, or take advantage of SVG components to layer on custom annotations. Several advanced React components are available offering varying degrees of customization.","title":"Overview"},{"location":"custom/#custom-alphabets","text":"You can use any combination of symbols you like in your logos. The custom alphabets page in the Building blocks: glyphs and alphabets section has details. Once you have a custom alphabet, you can render a logo with it using the Logo component, which takes the following properties: values : a matrix containing nucleotide frequencies at each position. Each row is a position in the logo, and the columns correspond to the symbol order defined in the alphabet array. mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. alphabet : the custom alphabet containing the symbols the logos should render. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default 1 / (alphabet length). The order of the array matches the order of alphabet . If mode is not INFORMATION_CONTENT, this is ignored. The following complete example renders a logo with M and W representing methylated CpG : import { Logo } from logosj-react ; const METHYL_VALUES = [ [ 0 , 0 , 0 , 1 , 0 , 0 ] [ 0 , 0 , 0 , 1 , 0 , 0 ] [ 0.3 , 0 , 0.3 , 0.4 , 0 , 0 ] [ 0 , 0 , 0 , 0 , 1 , 0 ] [ 0 , 0 , 0 , 0 , 0 , 1 ] [ 0 , 0.6 , 0 , 0.4 , 0 , 0 ] [ 1 , 0 , 0 , 0 , 0 , 0 ] ]; const METHYL_ALPHABET = [ { color : #880088 , regex : A } { color : #880000 , regex : C } { color : #000088 , regex : G } { color : #888800 , regex : T } { color : #ff0000 , regex : M } { color : #008888 , regex : W } ]; export const MethylLogo = props = ( Logo values = { METHYL_VALUES } alphabet = { METHYL_ALPHABET } / ); To embed a Logo outside of React, use the embedLogo function, which takes the following arguments: div the div element in which to render the logo properties object containing the properties listed above","title":"Custom alphabets"},{"location":"custom/#negative-letters","text":"The LogosWithNegatives component allows letters to extend below the x-axis. In this case, the values in the matrix represent the raw heights above (or below) the x-axis, and the y-axis will autoscale. The component accepts the following properties: values matrix containing the heights of the letters at each position; values can be positive or negative. startpos if set, the first base in the logo will be numbered with a value other than the default of 1. alphabet the custom alphabet containing the symbols the logos should render. negativealpha if provided, specifies that letters below the x-axis should be semi-transparent inverted if provided, specifies that letters below the x-axis should be rendered upright rather than upside-down, which is the default. The following complete example renders a DNA logo with some negative letters: import { LogoWithNegatives , DNAAlphabet } from logosj-react ; const DNA_VALUES = [ [ 0 , 0 , 0 , 0 ], [ - 0.5 , 0.5 , - 0.5 , 0.5 ], [ 0.5 , - 2 , - 2 , 3 ], [ 2.5 , - 2 , 0.5 , - 0.5 ], [ 4.5 , - 1 , - 2 , - 2.5 ], [ - 1 , - 1 , 0 , 2 ], [ - 1.5 , - 0.5 , 0.5 , 1.5 ], [ 1.5 , - 1.5 , 1 , - 0.5 ], [ - 1 , 1 , 0 , 0 ] [ 0 , 0 , 0 , 0 ] ]; export const DNALogo = props = ( LogoWithNegatives values = { DNA_VALUES } alphabet = { DNAAlphabet } negativealpha = { 101 } / ); To embed a LogoWithNegatives outside of React, use the embedLogoWithNegatives function, which takes the following arguments: div the div element in which to render the logo properties object containing the properties listed above","title":"Negative letters"},{"location":"custom/#logos-without-axes","text":"Logos do not need to be rendered with the default, built-in axes. LogosJ provides a RawLogo component which just renders glyphs. A RawLogo component does not render its own svg tag; you need to provide it yourself. This adds flexibility, however, to render the logo on top of other SVG annotations. The value matrix passed to a RawLogo specifies the raw heights of the contained letters. A value of 1 will render a letter which is 100 units high, relative to the SVG s coordinate system. By default, all positions are 100 units wide. RawLogo components support multiple letters per symbol. A RawLogo takes the following properties: values matrix containing the raw heights of the letters (divided by a factor of 100 units relative to the SVG s coordinate system). glyphWidth the width of a single glyph relative to the containing SVG s coordinate system; defaults to 100. stackHeight the height of a single stack of glyphs relative to the containing SVG s coordinate system; defaults to 100. Individual letters can exceed this, in which case they may extend past the SVG s borders. alphabet the custom alphabet containing the symbols the logos should render. The following example renders a RawLogo containing a DNA sequence with some letters grayed out. Note that the RawLogo must be rendered within a containing svg , and is shifted to the desired position by transforming a g element: import { RawLogo } from logosj-react ; const ANNOTATED_VALUES = [ [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 ] [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 0 , 0.25 , 0.25 , 0.25 , 0.25 ] [ 0 , 0 , 0 , 0 , 0.25 , 0.25 , 0.25 , 0.25 ] [ 0 , 0 , 0 , 0 , 0.25 , 0.25 , 0.25 , 0.25 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] [ 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 ] ]; const ANNOTATED_ALPHABET = [ { regex : A , color : red } { regex : C , color : blue } { regex : G , color : orange } { regex : T , color : #228b22 } { color : #aaaaaa , regex : A } { color : #aaaaaa , regex : C } { color : #aaaaaa , regex : G } { color : #aaaaaa , regex : T } ]; export const AnnotatedLogo = props = ( svg viewBox = 0 0 1530 330 g transform = translate(20,-40) id = logo RawLogo values = { ANNOTATED_VALUES } alphabet = { ANNOTATED_ALPHABET } glyphWidth = { 100 } stackHeight = { 300 } / /g /svg ); To embed a RawLogo outside of React, use the embedRawLogo function, which takes the following arguments: element the SVG element in which to render the logo properties object containing the properties listed above","title":"Logos without axes"},{"location":"custom/#custom-annotations","text":"When a RawLogo is rendered within an svg , a variety of custom annotations can be layered on as desired using custom SVG components. The following example renders two logos on top of each other, one representing a reference sequence with a SNP and the other a motif interrupted by the SNP. The SNP is highlighted in gray and the logos labeled with text labels. For more examples, see our companion site, http://logosj.wenglab.org/ . import { RawLogo , DNAAlphabet } from logosj-react ; const SNP_VALUES = [ [ 0.05 , 0.05 , 0 , 0 ] [ 0 , 0 , 0.3 , 0.7 ] [ 0 , 0 , 0.05 , 0.05 ] [ 0 , 0 , 0 , 2 ] [ 0.6 , 0 , 0 , 0.8 ] [ 0 , 2 , 0 , 0 ] [ 0.8 , 0.8 , 0 , 0 ] [ 0 , 0 , 0.1 , 0 ] ]; const REFERENCE_VALUES = [ [ 2 , 0 , 0 , 0 ] [ 0 , 0 , 0 , 2 ] [ 2 , 0 , 0 , 0 ] [ 0 , 2 , 0 , 0 ] [ 0 , 0 , 0 , 2 ] [ 0 , 2 , 0 , 0 ] [ 0 , 2 , 0 , 0 ] [ 0 , 0 , 0 , 2 ] ]; export const SNPLogo = props = ( svg viewBox = 0 0 1100 420 rect x = { 600 } width = { 100 } height = { 420 } fill = #bbbbbb / g transform = translate(300,0) RawLogo alphabet = { DNAAlphabet } values = { SNP_VALUES } glyphWidth = { 100 } stackHeight = { 200 } / /g g transform = translate(300, 220) RawLogo alphabet = { DNAAlphabet } values = { REFERENCE_VALUES } glyphWidth = { 100 } stackHeight = { 200 } / /g text y = { 150 } x = { 260 } textAnchor = end style = {{ fontSize : 50px }} motif /text text y = { 350 } x = { 260 } textAnchor = end style = {{ fontSize : 50px }} reference /text /svg );","title":"Custom annotations"},{"location":"dna_logos/","text":"Rendering DNA logos With React: DNALogo component The DNALogo component renders a logo with the DNAAlphabet (A, C, G, and T) with accompanying x- and y-axes. The color scheme used for the letters is similar to MEME; A is red, C is blue, G is gold, and T is green. The logo can use either information content (0-2 bits) or base frequency (0%-100%) for letter heights at each position. If you need custom axes, custom colors, or a custom alphabet, use the Logo or RawLogo compoenent instead. If you need negative letter heights, use the LogoWithNegatives component instead. The following is a CTCF logo rendered with the default DNALogo component: DNALogo takes the following properties: ppm : a matrix containing nucleotide frequencies at each position, ranging from 0.0 to 1.0. Each row is a position in the logo, and the columns are alphabetical (A, C, G, U). pfm : a matrix containing the number of times a nucleotide occurs at each position; this is only used if ppm is not provided. The row and column orders are the same as for ppm . mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default for each nucleotide. The order of the array is A, C, G, U. If mode is not INFORMATION_CONTENT, this is ignored. import { DNALogo } from logosj-react ; const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const CTCFLogo = props = ( DNALogo ppm = { CTCF_PPM } / ); Without React: embedDNALogo function Outside of React, use the logosj.embedDNALogo function to embed a DNALogo component in a div . logosj.embedDNALogo takes two arguments: div : HTML element in which to embed the DNA logo; its innerHTML will be replaced by the rendered logo. properties : an object containing the above properties. If you don t use React, the following code embeds the DNA logo in a div element: !doctype html html body script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedDNALogo ( document . getElementById ( logo ), { ppm : CTCF_PPM }); / script / body / html","title":"DNA logos"},{"location":"dna_logos/#rendering-dna-logos","text":"","title":"Rendering DNA logos"},{"location":"dna_logos/#with-react-dnalogo-component","text":"The DNALogo component renders a logo with the DNAAlphabet (A, C, G, and T) with accompanying x- and y-axes. The color scheme used for the letters is similar to MEME; A is red, C is blue, G is gold, and T is green. The logo can use either information content (0-2 bits) or base frequency (0%-100%) for letter heights at each position. If you need custom axes, custom colors, or a custom alphabet, use the Logo or RawLogo compoenent instead. If you need negative letter heights, use the LogoWithNegatives component instead. The following is a CTCF logo rendered with the default DNALogo component: DNALogo takes the following properties: ppm : a matrix containing nucleotide frequencies at each position, ranging from 0.0 to 1.0. Each row is a position in the logo, and the columns are alphabetical (A, C, G, U). pfm : a matrix containing the number of times a nucleotide occurs at each position; this is only used if ppm is not provided. The row and column orders are the same as for ppm . mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default for each nucleotide. The order of the array is A, C, G, U. If mode is not INFORMATION_CONTENT, this is ignored. import { DNALogo } from logosj-react ; const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const CTCFLogo = props = ( DNALogo ppm = { CTCF_PPM } / );","title":"With React: DNALogo component"},{"location":"dna_logos/#without-react-embeddnalogo-function","text":"Outside of React, use the logosj.embedDNALogo function to embed a DNALogo component in a div . logosj.embedDNALogo takes two arguments: div : HTML element in which to embed the DNA logo; its innerHTML will be replaced by the rendered logo. properties : an object containing the above properties. If you don t use React, the following code embeds the DNA logo in a div element: !doctype html html body script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const CTCF_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedDNALogo ( document . getElementById ( logo ), { ppm : CTCF_PPM }); / script / body / html","title":"Without React: embedDNALogo function"},{"location":"glyph/","text":"Built-in and custom glyphs Glyph overview Glyphs are the smallest building blocks of LogosJ logos. Each glyph is a self-contained SVG object which renders itself within a 100 by 100 square. Logo components are responsible for applying the appropriate transforms to the glyph objects they contain to adjust their positions within the logo and their heights. Built-in glyphs LogosJ uses a custom font to render its glyphs, which include the capital letters A-Z, the lower case letters a-z, and the digits 0-9. Most glyphs contain a single SVG path element, and apply their props directly to it. You can apply properties including, but not limited to: fill : the color of the glyph. fillOpacity : number from 0 to 1 representing transparency, with 0 being transparent and 1 being opaque. In general, it is not necessary to render glyphs directly; instead, they should be passed as properties to logo components in alphabet arrays (see the alphabet page for details). When you need to include built-in symbols in a custom alphabet, you can import built-in glyphs directly from the LogosJ package. Capital letters are their own components; lower case letters are represented as LC_a, LC_b, etc. and numbers as N1, N2, etc. For example the following code imports capital A, lower case a, and the number 1: import { A , LC_a , N1 } from logosj ; In plain Javascript, these are available in the logosj namespace as logosj.A , logosj.LC_a , logosj.N1 , etc. Custom glyphs If you want to add a custom symbol which is not built in to LogosJ, you can make a custom glyph component. Glyph components should render an SVG element, such as a path or a collection of path s contained with a g , with a width of 100 and a height of 100. When rendered in a logo, your custom glyph will be scaled automatically. It is best practice to pass the full collection of properties your glyph receives on to the SVG element it renders. For example, here is the source code for LogosJ s built-in C , which passes all its properties on to a single child path : const _path = `M 100 28 C 100 -13 0 -13 0 50 C 0 113 100 113 100 72 L 75 72 C 75 90 30 90 30 50 C 30 10 75 10 75 28 L 100 28` ; export const C = props = ( path {... props } d = { _path } / ); To render a custom symbol, you could simply replace the path data above with your own. At the very least, your custom glyph should support fill which determines its color and fillOpacity which determines its transparency. For instructions on how to include your custom glyph in a logo, see the custom alphabets section.","title":"Glyphs and custom symbols"},{"location":"glyph/#built-in-and-custom-glyphs","text":"","title":"Built-in and custom glyphs"},{"location":"glyph/#glyph-overview","text":"Glyphs are the smallest building blocks of LogosJ logos. Each glyph is a self-contained SVG object which renders itself within a 100 by 100 square. Logo components are responsible for applying the appropriate transforms to the glyph objects they contain to adjust their positions within the logo and their heights.","title":"Glyph overview"},{"location":"glyph/#built-in-glyphs","text":"LogosJ uses a custom font to render its glyphs, which include the capital letters A-Z, the lower case letters a-z, and the digits 0-9. Most glyphs contain a single SVG path element, and apply their props directly to it. You can apply properties including, but not limited to: fill : the color of the glyph. fillOpacity : number from 0 to 1 representing transparency, with 0 being transparent and 1 being opaque. In general, it is not necessary to render glyphs directly; instead, they should be passed as properties to logo components in alphabet arrays (see the alphabet page for details). When you need to include built-in symbols in a custom alphabet, you can import built-in glyphs directly from the LogosJ package. Capital letters are their own components; lower case letters are represented as LC_a, LC_b, etc. and numbers as N1, N2, etc. For example the following code imports capital A, lower case a, and the number 1: import { A , LC_a , N1 } from logosj ; In plain Javascript, these are available in the logosj namespace as logosj.A , logosj.LC_a , logosj.N1 , etc.","title":"Built-in glyphs"},{"location":"glyph/#custom-glyphs","text":"If you want to add a custom symbol which is not built in to LogosJ, you can make a custom glyph component. Glyph components should render an SVG element, such as a path or a collection of path s contained with a g , with a width of 100 and a height of 100. When rendered in a logo, your custom glyph will be scaled automatically. It is best practice to pass the full collection of properties your glyph receives on to the SVG element it renders. For example, here is the source code for LogosJ s built-in C , which passes all its properties on to a single child path : const _path = `M 100 28 C 100 -13 0 -13 0 50 C 0 113 100 113 100 72 L 75 72 C 75 90 30 90 30 50 C 30 10 75 10 75 28 L 100 28` ; export const C = props = ( path {... props } d = { _path } / ); To render a custom symbol, you could simply replace the path data above with your own. At the very least, your custom glyph should support fill which determines its color and fillOpacity which determines its transparency. For instructions on how to include your custom glyph in a logo, see the custom alphabets section.","title":"Custom glyphs"},{"location":"protein_logos/","text":"Rendering Protein logos With React: ProteinLogo component The ProteinLogo component renders a logo with the ProteinAlphabet (22 amino acids plus B and Z ) with accompanying x- and y-axes. The color scheme corresponds to the chemical properties of the amino acids: acidic is red, basic is blue, non-polar is black, and ambiguous ( B - N or D and Z - Q or E ) are gold. The logo can use either information content (0-4.5 bits) or amino acid frequency (0%-100%) for letter heights at each position. If you need custom axes, custom colors, or a custom alphabet, use the Logo or RawLogo compoenent instead. If you need negative letter heights, use the LogoWithNegatives component instead. The following is a logo for the helix turn helix motif of the catabolite activator protein (CAP) family: ProteinLogo takes the following properties: ppm : a matrix containing amino acid frequencies at each position, ranging from 0.0 to 1.0. Each row is a position in the logo, and the columns are alphabetical. pfm : a matrix containing the number of times each amino acid occurs at each position. This is only used if ppm is not provided. Column and row orders are the same as for ppm . mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default 1/20 for each amino acid. The order of the array is alphabetical. If mode is not INFORMATION_CONTENT, this is ignored. import { ProteinLogo } from logosj-react ; const CAP_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const CAPLogo = props = ( ProteinLogo ppm = { CAP_PPM } / ); Without React: embedProteinLogo function Outside of React, use the logosj.embedProteinLogo function to embed a ProteinLogo component in a div . logosj.embedProteinLogo takes two arguments: div : HTML element in which to embed the Protein logo; its innerHTML will be replaced by the rendered logo. properties : an object containing the above properties. If you don t use React, the following code embeds the Protein logo in a div element: !doctype html html body script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const CAP_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedProteinLogo ( document . getElementById ( logo ), { ppm : CAP_PPM }); / script / body / html","title":"Protein logos"},{"location":"protein_logos/#rendering-protein-logos","text":"","title":"Rendering Protein logos"},{"location":"protein_logos/#with-react-proteinlogo-component","text":"The ProteinLogo component renders a logo with the ProteinAlphabet (22 amino acids plus B and Z ) with accompanying x- and y-axes. The color scheme corresponds to the chemical properties of the amino acids: acidic is red, basic is blue, non-polar is black, and ambiguous ( B - N or D and Z - Q or E ) are gold. The logo can use either information content (0-4.5 bits) or amino acid frequency (0%-100%) for letter heights at each position. If you need custom axes, custom colors, or a custom alphabet, use the Logo or RawLogo compoenent instead. If you need negative letter heights, use the LogoWithNegatives component instead. The following is a logo for the helix turn helix motif of the catabolite activator protein (CAP) family: ProteinLogo takes the following properties: ppm : a matrix containing amino acid frequencies at each position, ranging from 0.0 to 1.0. Each row is a position in the logo, and the columns are alphabetical. pfm : a matrix containing the number of times each amino acid occurs at each position. This is only used if ppm is not provided. Column and row orders are the same as for ppm . mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default 1/20 for each amino acid. The order of the array is alphabetical. If mode is not INFORMATION_CONTENT, this is ignored. import { ProteinLogo } from logosj-react ; const CAP_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const CAPLogo = props = ( ProteinLogo ppm = { CAP_PPM } / );","title":"With React: ProteinLogo component"},{"location":"protein_logos/#without-react-embedproteinlogo-function","text":"Outside of React, use the logosj.embedProteinLogo function to embed a ProteinLogo component in a div . logosj.embedProteinLogo takes two arguments: div : HTML element in which to embed the Protein logo; its innerHTML will be replaced by the rendered logo. properties : an object containing the above properties. If you don t use React, the following code embeds the Protein logo in a div element: !doctype html html body script src = http://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const CAP_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedProteinLogo ( document . getElementById ( logo ), { ppm : CAP_PPM }); / script / body / html","title":"Without React: embedProteinLogo function"},{"location":"rna_logos/","text":"Rendering RNA logos With React: RNALogo component The RNALogo component renders a logo with the RNAAlphabet (A, C, G, and U) with accompanying x- and y-axes. The color scheme used for the letters is similar to MEME; A is red, C is blue, G is gold, and U is green. The logo can use either information content (0-2 bits) or base frequency (0%-100%) for letter heights at each position. If you need custom axes, custom colors, or a custom alphabet, use the Logo or RawLogo compoenent instead. If you need negative letter heights, use the LogoWithNegatives component instead. The following is a logo for the QKI RNA binding protein, which binds a consensus sequence of ACUAAC : RNALogo takes the following properties: ppm : a matrix containing nucleotide frequencies at each position, ranging from 0.0 to 1.0. Each row is a position in the logo, and the columns are alphabetical (A, C, G, U). pfm : a matrix containing the number of times a nucleotide occurs at each position; this is only used if ppm is not provided. The row and column orders are the same as for ppm . mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default for each nucleotide. The order of the array is A, C, G, U. If mode is not INFORMATION_CONTENT, this is ignored. import { RNALogo } from logosj-react ; const QKI_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const QKILogo = props = ( RNALogo ppm = { QKI_PPM } / ); Without React: embedRNALogo function Outside of React, use the logosj.embedRNALogo function to embed a RNALogo component in a div . logosj.embedRNALogo takes two arguments: div : HTML element in which to embed the RNA logo; its innerHTML will be replaced by the rendered logo. properties : an object containing the above properties. If you don t use React, the following code embeds the RNA logo in a div element: !doctype html html body script src = https://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const QKI_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedRNALogo ( document . getElementById ( logo ), { ppm : QKI_PPM }); / script / body / html","title":"RNA logos"},{"location":"rna_logos/#rendering-rna-logos","text":"","title":"Rendering RNA logos"},{"location":"rna_logos/#with-react-rnalogo-component","text":"The RNALogo component renders a logo with the RNAAlphabet (A, C, G, and U) with accompanying x- and y-axes. The color scheme used for the letters is similar to MEME; A is red, C is blue, G is gold, and U is green. The logo can use either information content (0-2 bits) or base frequency (0%-100%) for letter heights at each position. If you need custom axes, custom colors, or a custom alphabet, use the Logo or RawLogo compoenent instead. If you need negative letter heights, use the LogoWithNegatives component instead. The following is a logo for the QKI RNA binding protein, which binds a consensus sequence of ACUAAC : RNALogo takes the following properties: ppm : a matrix containing nucleotide frequencies at each position, ranging from 0.0 to 1.0. Each row is a position in the logo, and the columns are alphabetical (A, C, G, U). pfm : a matrix containing the number of times a nucleotide occurs at each position; this is only used if ppm is not provided. The row and column orders are the same as for ppm . mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. backgroundFrequencies : optional; an array of background frequencies to use to compute information content in place of the default for each nucleotide. The order of the array is A, C, G, U. If mode is not INFORMATION_CONTENT, this is ignored. import { RNALogo } from logosj-react ; const QKI_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; export const QKILogo = props = ( RNALogo ppm = { QKI_PPM } / );","title":"With React: RNALogo component"},{"location":"rna_logos/#without-react-embedrnalogo-function","text":"Outside of React, use the logosj.embedRNALogo function to embed a RNALogo component in a div . logosj.embedRNALogo takes two arguments: div : HTML element in which to embed the RNA logo; its innerHTML will be replaced by the rendered logo. properties : an object containing the above properties. If you don t use React, the following code embeds the RNA logo in a div element: !doctype html html body script src = https://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const QKI_PPM = [ [ 0.09 , 0.31 , 0.08 , 0.50 ], [ 0.18 , 0.15 , 0.45 , 0.20 ], [ 0.30 , 0.05 , 0.49 , 0.14 ], [ 0.06 , 0.87 , 0.02 , 0.03 ], [ 0.00 , 0.98 , 0.00 , 0.02 ], [ 0.81 , 0.01 , 0.07 , 0.09 ], [ 0.04 , 0.57 , 0.36 , 0.01 ], [ 0.11 , 0.47 , 0.05 , 0.35 ], [ 0.93 , 0.01 , 0.03 , 0.01 ], [ 0.00 , 0.00 , 0.99 , 0.01 ], [ 0.36 , 0.00 , 0.64 , 0.00 ], [ 0.05 , 0.01 , 0.55 , 0.37 ], [ 0.03 , 0.00 , 0.97 , 0.00 ], [ 0.06 , 0.00 , 0.85 , 0.07 ], [ 0.11 , 0.80 , 0.00 , 0.07 ], [ 0.40 , 0.01 , 0.55 , 0.01 ], [ 0.09 , 0.53 , 0.33 , 0.04 ], [ 0.12 , 0.35 , 0.08 , 0.43 ], [ 0.44 , 0.19 , 0.29 , 0.06 ] ]; logosj . embedRNALogo ( document . getElementById ( logo ), { ppm : QKI_PPM }); / script / body / html","title":"Without React: embedRNALogo function"},{"location":"_site/dnalogo/","text":"DNA logos Perhaps the most common use case for sequence logos is the standard DNA logo illustrating a consensus sequence. LogosJ comes with a DNALogo component built in. Letters are colored similarly to the MEME Suite default color scheme, and x- and y-axes are rendered alongside the logo. To embed the DNALogo, use the DNALogo component in React or call the logosj.embedDNALogo function. DNALogo accepts three properties: * pwm : a matrix containing nucleotide frequencies at each position. Each row is a position in the logo, and the columns are alphabetical (A, C, G, T). * mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . * startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. logosj.embedDNALogo takes two arguments: * div : HTML element in which to embed the DNA logo; its innerHTML will be replaced by the rendered logo. * properties : an object containing the above properties. The main page shows code examples for embedding the CTCF consensus binding sequence logo. RNA logos LogosJ also provides an RNALogo component. It uses the same color scheme as the DNA logo (U is green) and accepts the same properties as the DNALogo. To embed it, use the RNALogo React component or the embedRNALogo function. The QKI RNA binding protein binds a consensus sequence of ACUAAC : To embed this logo in React: import { RNALogo } from logosj-react ; const RNA_PWM = [ [0.7,0.1,0.1,0.1], [0,1,0,0], [0,0,0,1], [1,0,0,0], [1,0,0,0], [0,1,0,0], [0.3,0.2,0.3,0.2] ]; export const QKILogo = props = ( RNALogo pwm={RNA_PWM} / ); Or without React: !doctype html html body script src = https://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const RNA_PWM = [ [ 0.7 , 0.1 , 0.1 , 0.1 ] [ 0 , 1 , 0 , 0 ] [ 0 , 0 , 0 , 1 ] [ 1 , 0 , 0 , 0 ] [ 1 , 0 , 0 , 0 ] [ 0 , 1 , 0 , 0 ] [ 0.3 , 0.2 , 0.3 , 0.2 ] ]; logosj . embedRNALogo ( document . getElementById ( logo ), { pwm : RNA_PWM }); / script / body / html","title":"Dnalogo"},{"location":"_site/dnalogo/#dna-logos","text":"Perhaps the most common use case for sequence logos is the standard DNA logo illustrating a consensus sequence. LogosJ comes with a DNALogo component built in. Letters are colored similarly to the MEME Suite default color scheme, and x- and y-axes are rendered alongside the logo. To embed the DNALogo, use the DNALogo component in React or call the logosj.embedDNALogo function. DNALogo accepts three properties: * pwm : a matrix containing nucleotide frequencies at each position. Each row is a position in the logo, and the columns are alphabetical (A, C, G, T). * mode : determines how letter heights are computed; may be either \"INFORMATION_CONTENT\" (default) or \"FREQUENCY\" . * startpos : if set, the first base in the logo will be numbered with a value other than the default of 1. logosj.embedDNALogo takes two arguments: * div : HTML element in which to embed the DNA logo; its innerHTML will be replaced by the rendered logo. * properties : an object containing the above properties. The main page shows code examples for embedding the CTCF consensus binding sequence logo.","title":"DNA logos"},{"location":"_site/dnalogo/#rna-logos","text":"LogosJ also provides an RNALogo component. It uses the same color scheme as the DNA logo (U is green) and accepts the same properties as the DNALogo. To embed it, use the RNALogo React component or the embedRNALogo function. The QKI RNA binding protein binds a consensus sequence of ACUAAC : To embed this logo in React: import { RNALogo } from logosj-react ; const RNA_PWM = [ [0.7,0.1,0.1,0.1], [0,1,0,0], [0,0,0,1], [1,0,0,0], [1,0,0,0], [0,1,0,0], [0.3,0.2,0.3,0.2] ]; export const QKILogo = props = ( RNALogo pwm={RNA_PWM} / ); Or without React: !doctype html html body script src = https://bundle.logosj.wenglab.org/bundle.js type = text/javascript / script div id = logo style = width:500px / div script type = text/javascript const RNA_PWM = [ [ 0.7 , 0.1 , 0.1 , 0.1 ] [ 0 , 1 , 0 , 0 ] [ 0 , 0 , 0 , 1 ] [ 1 , 0 , 0 , 0 ] [ 1 , 0 , 0 , 0 ] [ 0 , 1 , 0 , 0 ] [ 0.3 , 0.2 , 0.3 , 0.2 ] ]; logosj . embedRNALogo ( document . getElementById ( logo ), { pwm : RNA_PWM }); / script / body / html","title":"RNA logos"}]}